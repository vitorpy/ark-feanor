{"id":"ark-feanor-1w9","content_hash":"fbd6f2f315b8b73ace0510addc995e336222e63f221f7f65e1163fdd63d26b74","title":"SHT-driven symbolic closure (bounded)","description":"\nTitle: SHT-driven symbolic closure (bounded)\n\nGoal\n- Perform closure to add exactly one reducer per A-block column (skip pivot LCMs). Drive closure from SHT, with bounded passes (\u003c=2) or until no change.\n\nDesign\n- Build LM index once per round: (basis_idx, LM, degree, expanded exponents) with degree+per-variable prefilters and a final monomial_div check.\n- Target A-columns:\n  - Start with LCM columns and leftmost columns from rr/tr rows; optionally iterate over SHT entries with idx=1.\n  - For each target col c not in pivots, select the first basis LM dividing the monomial of c, then add row = (monomial/LT(b))*b.\n  - Insert reducer row via polynomial_to_row, filter entries to A-block only (no tails).\n  - Update SHT with idx=1 for new row monomials.\n- Repeat for up to 2 passes or stop early if rows/cols unchanged.\n\nWhere to implement\n- src/f4/mod.rs closure section.\n\nAcceptance\n- rows+red/cols+red deltas remain modest; elimination time does not dominate closure time.\n- No stalls; every round progresses.\n\nPitfalls\n- Ensure pivot LCM columns are always skipped in closure.\n- Keep closures strictly bounded to prevent blow-up.\n","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-11-17T15:24:44.668381689+01:00","updated_at":"2025-11-17T16:28:27.310660757+01:00","closed_at":"2025-11-17T16:28:27.310660757+01:00","source_repo":"."}
{"id":"ark-feanor-29t","content_hash":"ca0fabecf88001699669376882b34e46245a1182f5de8ceb5bd03175a509163a","title":"Build rr/tr rows as multiplied basis elements","description":"\nTitle: Build rr/tr rows as multiplied basis elements\n\nGoal\n- For each LCM group (from selection), build rr/tr rows as multiplied basis rows — not explicit S-polynomial rows — mirroring msolve symbol.c.\n\nDesign\n- For a group (LCM, gens):\n  - Sort gens (unique basis indices).\n  - rr row: first gen b_0 → (LCM / LT(b_0)) * b_0\n  - tr rows: for each remaining b_i → (LCM / LT(b_i)) * b_i\n- Insert rows into the matrix via polynomial_to_row(). Ensure LCM columns exist (get_or_create_column) and seed SHT with idx=2 for LCM.\n- Insert rr/tr monomial entries into SHT with idx=1 as they appear.\n\nWhere to implement\n- src/f4/mod.rs, in place of prior S-polynomials-to-rows logic; build rows using basis and multipliers.\n\nAcceptance\n- The first column (leftmost term) of rr/tr rows is the LCM or subordinate A-column after mapping.\n- rr/tr counts match number of LCMs and number of gens per group.\n\nPitfalls\n- Handle cases where LCM/LT(b) is not defined (should not happen if gens are correct); skip invalid rows.\n- Avoid borrowing issues: clone monomials before mutating the matrix.\n","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-11-17T15:24:28.983784529+01:00","updated_at":"2025-11-17T16:07:03.866366936+01:00","closed_at":"2025-11-17T16:07:03.866366936+01:00","source_repo":"."}
{"id":"ark-feanor-3er","content_hash":"7d11a9acede85df7bdff4fd7c34921acbcd0eefce7cf566a41f5530a61a42885","title":"Row ordering: pivot then density (order.c)","description":"\nTitle: Row ordering: pivot then density (order.c)\n\nGoal\n- Post-mapping, sort rows by pivot column and then by row length to improve elimination locality and reuse, mirroring msolve order.c matrix_row_cmp_increasing behavior.\n\nDesign\n- After A|B mapping, sort rows by:\n  1) pivot column (leftmost index), ascending\n  2) row length (LENGTH), ascending\n- Do not sort before mapping or pre-mark pivot rows.\n\nWhere to implement\n- src/f4/mod.rs just before reduce_matrix.\n\nAcceptance\n- Slight reduction in elimination time per round, especially on larger matrices.\n\nPitfalls\n- Ensure no borrow issues; sorting should happen on the rows vector only after mapping.\n","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-17T15:25:22.621622531+01:00","updated_at":"2025-11-17T15:29:12.323767411+01:00","source_repo":"."}
{"id":"ark-feanor-52e","content_hash":"f51d403f6c32764a3015defb1d41aa5b7c32f916b9ba053f83e0fcbd93efa2a6","title":"Divmask fast divisibility prefilter","description":"\nTitle: Divmask fast divisibility prefilter\n\nGoal\n- Reduce monomial_div calls in closure and GM by adding a short divisor mask per LM and per target monomial (coarse bitset over exponent bins), like msolve hash.c.\n\nDesign\n- Choose a conservative binning for exponents (e.g., small number of bins across variables) to generate a fixed-size bitset per monomial.\n- A divides B ⇒ mask(A) ⊆ mask(B) must hold; if not, skip monomial_div entirely.\n- Compute masks once per round for all basis LMs and monomials encountered in SHT; store alongside expanded exponents.\n\nWhere to implement\n- src/f4/mod.rs (LMIndexEntry), integrate into reducer search and GM pruning.\n\nAcceptance\n- Closure and GM spend less time in monomial_div; improved scaling on larger instances.\n\nPitfalls\n- Keep masks conservative to avoid false positives (i.e., allowing monomial_div if mask passes), but strive for high rejection rate for false candidates.\n","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-17T15:25:14.892172525+01:00","updated_at":"2025-11-17T15:29:04.88813119+01:00","source_repo":"."}
{"id":"ark-feanor-63y","content_hash":"855690594bccc656f9d71680dd82aa4a795cc2505ece7ffd3f4a8e02cafb2fcb","title":"Add per-round SHT (secondary hash table)","description":"\nTitle: Add per-round SHT (secondary hash table)\n\nGoal\n- Introduce a minimal per-round SHT-like index to track monomials encountered in the round and their roles:\n  - idx=2 for pivot LCM monomials\n  - idx=1 for reducer monomials (rr/tr rows, closure rows)\n- SHT drives both symbolic closure and A|B column mapping (convert_hashes_to_columns behavior in msolve).\n\nWhere to implement\n- src/f4/mod.rs (round scope). Use HashMap\u003cVec\u003cusize\u003e, u8\u003e.\n- Seed SHT with LCM monomials (idx=2).\n- As rr/tr rows are constructed, insert their monomials with idx=1.\n- As closure adds reducers, insert their monomials with idx=1.\n\nUsage\n- Closure: iterate over target A-columns and/or over SHT entries to add exactly one reducer per A-column (skip idx=2).\n- Mapping: pass SHT to matrix.reorder_columns_with_sht() to put idx=2 first, then idx=1, then tails.\n\nAcceptance\n- SHT contains all rr/tr and closure monomials by the time we map.\n- Column mapping uses SHT order, not ad-hoc index lists.\n\nPitfalls\n- Ensure consistent expansion Vec\u003cusize\u003e and reuse for SHT keys; avoid recomputing expansions excessively.\n","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-11-17T15:24:24.288193294+01:00","updated_at":"2025-11-17T16:07:03.750197944+01:00","closed_at":"2025-11-17T16:07:03.750197944+01:00","source_repo":"."}
{"id":"ark-feanor-689","content_hash":"e752048bc38ffd4d7cc0d38b391444fd38cdc0b6d9ef1ddbc2f33ad8f23d0897","title":"Remove ad-hoc behavior and unify flags","description":"\nTitle: Remove ad-hoc behavior and unify flags\n\nGoal\n- Eliminate ad-hoc or conflicting behaviors and unify feature flags so strict msolve parity (for tests) and optimized behavior (for performance) can be toggled cleanly.\n\nDesign\n- Remove:\n  - Pre-marking pivot rows and pre-elimination row sorts\n  - Unfiltered fallback reducer paths\n- Feature-gate:\n  - A-block-only reducer filtering (strict parity off; optimized on)\n  - AB pre-reduction path before full elimination\n\nWhere to implement\n- src/f4/mod.rs and src/f4/gaussian.rs (guard optional paths behind cfg feature flags).\n\nAcceptance\n- Deterministic behavior; easy toggling for parity vs performance runs.\n\nPitfalls\n- Always keep default path safe and aligned with msolve before enabling optimizations.\n","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-17T15:25:33.163372202+01:00","updated_at":"2025-11-17T15:29:21.844641161+01:00","source_repo":"."}
{"id":"ark-feanor-87a","content_hash":"137921b92b233198f1f9143e4597380583ac7716af9328ee17bb8826885d2bac","title":"Epic: Complete msolve-aligned F4","description":"\nTitle: Epic: Complete msolve-aligned F4\n\nObjective\n- Achieve COMPLETE behavioral alignment with msolve’s F4 per‑round algorithm (not just intent).\n- Mirror msolve’s phases: selection (LCM‑grouped minimal degree), rr/tr construction from multiplied basis rows, SHT‑driven symbolic preprocessing (closure), SHT‑driven A|B column mapping, sparse LA consistent with AB/CD semantics, exact GM pruning behavior, and fast divisibility prefilters (divmask).\n\nScope \u0026 Deliverables\n- Replace ad‑hoc S‑polynomial row construction with rr/tr via (LCM/LT(b))⋅b for each LCM group.\n- Introduce a per‑round SHT (secondary hash table) of monomials with idx flags (2=pivots, 1=reducer monomials) to drive closure and mapping.\n- Implement bounded symbolic closure to add exactly one reducer per A‑column; skip pivot columns.\n- Implement SHT‑driven A|B column mapping (convert_hashes_to_columns behavior) and post‑mapping row ordering per order.c equivalents.\n- Keep elimination consistent with AB/CD semantics; optionally add AB pre‑reduction if needed.\n- Implement bs-\u003ered marking to skip redundant S‑pairs and ensure GM parity with msolve’s update.c.\n- Add divmask for fast divisibility prefiltering (hash.c behavior) to reduce monomial_div calls.\n- Provide a benchmark/validation suite (Katsura, cyclic, random) that checks correctness and performance.\n\nReferences (msolve; behavior only)\n- Pair update + GM: src/neogb/update.c\n- Selection + rr/tr: src/neogb/symbol.c\n- Symbolic preprocessing: src/neogb/symbol.c (symbolic_preprocessing)\n- Column mapping: src/neogb/convert.c (convert_hashes_to_columns)\n- Row ordering: src/neogb/order.c\n- Divmask/hashing: src/neogb/hash.c\n\nAcceptance / DoD\n- Per‑round logs (with F4_PROFILE=1) show: #LCM groups equals pivots; modest reducers added; A‑block closure bounded (\u003c=2 passes); elimination no longer dominates; progress every round.\n- Benchmarks: with F4_PROFILE off, F4 matches or beats Buchberger on Katsura‑4/5/6; no stalls.\n- Correctness: ideal inclusion checks pass (Buchberger basis reduces to zero by F4 basis and vice versa when expected); parity on small controlled systems with msolve‑like settings.\n\nDependencies\n- Blocks on: ark-feanor-maq, ark-feanor-63y, ark-feanor-29t, ark-feanor-1w9, ark-feanor-fok, ark-feanor-91q, ark-feanor-8gf, ark-feanor-52e, ark-feanor-3er, ark-feanor-689, ark-feanor-g46\n","status":"open","priority":0,"issue_type":"epic","created_at":"2025-11-17T15:24:08.235410842+01:00","updated_at":"2025-11-17T15:27:57.904855502+01:00","source_repo":".","dependencies":[{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-maq","type":"blocks","created_at":"2025-11-17T15:25:50.893510654+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-63y","type":"blocks","created_at":"2025-11-17T15:25:50.91519+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-29t","type":"blocks","created_at":"2025-11-17T15:25:50.935884636+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-1w9","type":"blocks","created_at":"2025-11-17T15:25:50.955809438+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-fok","type":"blocks","created_at":"2025-11-17T15:25:50.977850993+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-91q","type":"blocks","created_at":"2025-11-17T15:25:51.002165134+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-8gf","type":"blocks","created_at":"2025-11-17T15:25:51.025810674+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-52e","type":"blocks","created_at":"2025-11-17T15:25:51.048857587+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-3er","type":"blocks","created_at":"2025-11-17T15:25:51.070504046+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-689","type":"blocks","created_at":"2025-11-17T15:25:51.09174441+01:00","created_by":"daemon"},{"issue_id":"ark-feanor-87a","depends_on_id":"ark-feanor-g46","type":"blocks","created_at":"2025-11-17T15:25:51.112700131+01:00","created_by":"daemon"}]}
{"id":"ark-feanor-8gf","content_hash":"390c19eacee4044e1c3071d1ee36384fe82d2882d96bd7873b838875c5220684","title":"Pairset update: bs-\u003ered marking and GM parity","description":"\nTitle: Pairset update: bs-\u003ered marking and GM parity\n\nGoal\n- Align pairset update with msolve update.c: maintain bs-\u003ered to skip generating S-pairs for redundant LMs; ensure GM (old/new) pruning matches multiples and same-LCM elimination rules precisely.\n\nDesign\n- Maintain red_flags parallel to basis elements: mark an element i as redundant if LM(basis[i]) divides LM(basis[j]) or vice versa when a new basis element j is added.\n- Skip generating new S-pairs with red elements (both old and newly added in the same round). Keep GM-old/GM-new as in update.c.\n\nWhere to implement\n- src/f4/mod.rs in the extraction + pair generation section; centralize GM and red flags.\n\nAcceptance\n- Fewer S-pairs over time; per-round selection/closure faster.\n- Small cases (Katsura-3) parity checks with msolve-like rules.\n\nPitfalls\n- Carefully order updates so new elements don’t generate pairs with soon-to-be-marked redundant elements.\n","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-17T15:25:07.554164036+01:00","updated_at":"2025-11-17T17:16:10.11973936+01:00","closed_at":"2025-11-17T17:16:10.11973936+01:00","source_repo":"."}
{"id":"ark-feanor-91q","content_hash":"6acd764283cb08ceefa07c31f5d5f3c2258b34c645a8109722601ca5df7ee0a0","title":"Sparse LA semantics aligned with AB/CD","description":"\nTitle: Sparse LA semantics aligned with AB/CD\n\nGoal\n- Ensure sparse elimination respects AB/CD semantics post-mapping: CD rows reduce against AB first; new pivots admitted consistently per mapped order.\n\nDesign\n- Keep full reduce_matrix for progress; optionally add reduce_by_existing_pivots (AB-only pre-reduction) and fallback to full reduction if no new polynomials are extracted in a round.\n- Avoid pre-marking pivot rows prior to reduce_matrix; let LA discover pivots based on leftmost columns after mapping.\n\nWhere to implement\n- src/f4/gaussian.rs (optional AB pre-reduction API exists), src/f4/mod.rs.\n\nAcceptance\n- No stalls; each round yields new polynomials or shrinks S-pairs.\n- Elimination times are in line with msolve once AB is closed.\n\nPitfalls\n- Pre-sorting rows or pre-marking pivot rows before elimination can invalidate invariants; do not do this.\n","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-17T15:25:02.667245352+01:00","updated_at":"2025-11-17T15:28:48.146846074+01:00","source_repo":"."}
{"id":"ark-feanor-col-fix","content_hash":"1105f00b22a89d68692c5c0eea140fb6a0b8f6df1fc17ec51590c313aeeea103","title":"Fix column reordering correctness bug","description":"Column reordering (reorder_columns_with_sht) causes correctness issues in F4 algorithm, producing fewer basis elements than expected.\n\n## Observed Behavior\nWhen column reordering is enabled (line 480 in mod.rs), the Katsura-3 test fails:\n- Expected: 3-5 basis elements\n- Actual: \u003c3 basis elements (test_f4_katsura_3 fails)\n\nProfiling shows that closure adds 0 reducers (rows+red=X (+0)) when reordering is enabled, but adds reducers correctly when disabled.\n\n## Root Cause Hypothesis\nThe issue appears to be related to how the A-block filtering interacts with column reordering:\n1. After reordering, pivot columns are 0..(pivot_count-1)\n2. Reducer rows are filtered to keep only entries `\u003c pivot_count`\n3. Something about this interaction causes valid reducers to be filtered out\n\nPossible causes:\n- The pivot_count value might be incorrect after reordering\n- The column indices in target_cols might reference wrong columns after reordering\n- The A-block filter `row.entries.retain(|(c, _)| *c \u003c pivot_count)` might be too aggressive\n\n## Required Investigation\n1. Add debug logging to track:\n   - pivot_count before/after reordering\n   - target_cols before/after reordering\n   - Number of reducer rows created vs. filtered out\n2. Verify that dedicated reducer logic (lines 500-540) uses correct pivot_count\n3. Check if closure logic (lines 542-611) collects correct target columns after reordering\n\n## Impact\n- ark-feanor-fok (SHT-driven A|B column mapping) is BLOCKED\n- Column reordering is currently DISABLED (line 480: `if false \u0026\u0026`)\n- Performance optimizations from A|B split are unavailable\n\n## Dependencies\nBlocks: ark-feanor-fok","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-11-17T16:28:08.443886764+01:00","updated_at":"2025-11-17T17:00:06.206875992+01:00","closed_at":"2025-11-17T17:00:06.206875992+01:00","source_repo":"."}
{"id":"ark-feanor-fok","content_hash":"f420a325fed7c5f487958d8ed2182c9db46049dc5e50c56e6c147a4e2ed0572f","title":"SHT-driven A|B column mapping (convert_hashes_to_columns)","description":"\nTitle: SHT-driven A|B column mapping (convert_hashes_to_columns)\n\nGoal\n- Map columns pivot-first using SHT idx flags to reproduce msolve convert_hashes_to_columns: idx==2 (pivots), then idx==1 (reducers), then remaining tails.\n\nDesign\n- Use matrix.reorder_columns_with_sht(\u0026sht_idx) to:\n  - Build new order: [idx==2 cols] + [idx==1 cols] + [tails]\n  - Remap row column indices; rebuild monomial_to_col.\n  - Keep pivot_rows remapped consistently.\n- Optionally compute ncl/ncr metadata for A|B counts.\n- (Optional) After mapping, sort rows by pivot then density per order.c.\n\nWhere to implement\n- src/f4/mod.rs after rr/tr + closure, before elimination.\n- Matrix API: src/f4/matrix.rs has reorder_columns_with_sht.\n\nAcceptance\n- Per-round logs show consistent A|B sizes; elimination times stabilize.\n- Pivot reuse is effective (no stalls due to misplaced columns).\n\nPitfalls\n- Do not pre-mark pivot rows and sort pre-mapping; sort only after mapping if needed.\n","notes":"Column reordering implementation exists (matrix.rs:193-259) and is optimized (uses sort_unstable_by_key), but has a correctness bug that causes test failures.\n\nCurrent status: DISABLED (mod.rs:480) pending fix for ark-feanor-col-fix.\n\nThe reorder_columns_with_sht method correctly implements the A|B split (idx=2 pivots first, idx=1 reducers, then tails), but something about the interaction with the closure/reducer logic causes incorrect results. Investigation needed.","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-11-17T15:24:49.593171372+01:00","updated_at":"2025-11-17T17:00:06.509837726+01:00","closed_at":"2025-11-17T17:00:06.509837726+01:00","source_repo":".","dependencies":[{"issue_id":"ark-feanor-fok","depends_on_id":"ark-feanor-col-fix","type":"blocks","created_at":"2025-11-17T16:29:44.659561732+01:00","created_by":"daemon"}]}
{"id":"ark-feanor-g46","content_hash":"d425ef2777626d3c2f7ef4f1d1ac964a1cfddf164a42cad8bdc692e12b0c6b2b","title":"Benchmark + validation suite vs msolve","description":"\nTitle: Benchmark + validation suite vs msolve\n\nGoal\n- Provide benchmarks and validation tests to compare F4 vs Buchberger and align behavior with msolve’s round semantics.\n\nDesign\n- Systems: Katsura (3..6), cyclic, random dense, random sparse.\n- Correctness: ideal inclusion — reduce Buchberger basis by F4 basis and vice versa (for parity targets).\n- Performance: run with F4_PROFILE=0; separately run with F4_PROFILE=1 for diagnostics.\n- Report: time per round, closure vs LA time proportion, number of LCM groups, rr/tr counts.\n\nWhere to implement\n- examples/ (extend f4_scaling_test.rs and compare_f4_buchberger.rs), add scripts if useful.\n\nAcceptance\n- F4 matches or beats Buchberger on Katsura‑4/5/6 and larger suites; no stalls.\n- Round logs show bounded closure and stable A|B mapping.\n\nPitfalls\n- Ensure debug prints are off for timing; use env toggles to avoid skew.\n","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-17T15:25:38.539440797+01:00","updated_at":"2025-11-17T15:29:43.320265976+01:00","source_repo":"."}
{"id":"ark-feanor-maq","content_hash":"16d798c3e50e09337c30b18361b8e810013029c076e6868aeb23e48537c97376","title":"Implement LCM-grouped minimal-degree selection","description":"\nTitle: Implement LCM-grouped minimal-degree selection\n\nGoal\n- At each round, select S-pairs at the minimal LCM degree and group by LCM (expanded monomial). Always include the same‑LCM tail.\n- If a per-round cap (mnsel) is set, cap by number of LCM groups, not by pairs. Preserve deterministic ordering.\n\nBackground\n- msolve groups S-pairs by LCM within the minimal degree and processes one rr/tr per LCM group. This yields cohesive A-blocks and better reuse.\n\nWhere to implement\n- src/f4/mod.rs, inside f4_configured(): after computing min_deg for the current round.\n\nDesign\n- For each SPoly (i,j) with lcm_degree == min_deg:\n  - Compute LCM = monomial_lcm(LT(fi), LT(fj)); expand to Vec\u003cusize\u003e key.\n  - Insert into HashMap\u003cVec\u003cusize\u003e, LcmGroup{ lcm_mono, gens: HashSet\u003cusize\u003e }\u003e.\n- Selection result = ordered list of LCM groups. If mnsel is set, take the first N groups, include same-LCM tail for the Nth group.\n- Preserve stable ordering (e.g., lexicographical on expanded LCM or by first appearance).\n\nAcceptance\n- Per-round logs show pivot_count equals number of LCM groups.\n- rr/tr generation uses these groups in the next phase; no flat S-polynomial row construction remains.\n\nPitfalls\n- Ensure expanded monomials use the same variable ordering as the ring.\n- Be careful with caps: cap LCM groups, not pair count.\n","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-11-17T15:24:18.666912343+01:00","updated_at":"2025-11-17T16:07:03.630886163+01:00","closed_at":"2025-11-17T16:07:03.630886163+01:00","source_repo":"."}
