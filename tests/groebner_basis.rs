//! Tests for Gröbner basis computation over cryptographic fields

use ark_feanor::*;
use ark_bn254::Fr as BnFr;
use ark_bls12_381::Fr as BlsFr;
use feanor_math::algorithms::buchberger::*;
use feanor_math::rings::multivariate::*;

#[test]
fn test_groebner_basis_trivial() {
    let field = RingValue::from(ArkFieldWrapper::<BnFr>::new());
    let poly_ring = MultivariatePolyRingImpl::new(&field, 2);
    
    // Trivial system: {1} (inconsistent)
    let system = vec![poly_ring.one()];
    
    let gb = buchberger(&poly_ring, system, DegRevLex, |_| {}).unwrap();
    
    // Should return {1}
    assert_eq!(gb.len(), 1);
    assert!(poly_ring.is_one(&gb[0]));
}

#[test]
fn test_groebner_basis_linear() {
    let field = RingValue::from(ArkFieldWrapper::<BlsFr>::new());
    let poly_ring = MultivariatePolyRingImpl::new(&field, 2);
    
    // Linear system: x + y - 2, x - y
    // Solution: x = 1, y = 1
    let system = poly_ring.with_wrapped_indeterminates(|[x, y]| {
        vec![
            x.clone() + y.clone() - 2,
            x.clone() - y.clone(),
        ]
    });
    
    let gb = buchberger(&poly_ring, system, Lex, |_| {}).unwrap();
    
    // Should get a basis that allows solving
    assert!(gb.len() > 0);
    assert!(gb.len() <= 2);
}

#[test]
fn test_groebner_basis_quadratic() {
    let field = &*BLS12_381_FR;
    let poly_ring = MultivariatePolyRingImpl::new(field, 2);
    
    // System: x^2 - 1, y^2 - 4
    // Solutions: (±1, ±2)
    let system = poly_ring.with_wrapped_indeterminates(|[x, y]| {
        vec![
            x.clone().pow(2) - 1,
            y.clone().pow(2) - 4,
        ]
    });
    
    let gb = buchberger(&poly_ring, system, DegRevLex, |_| {}).unwrap();
    
    // The basis should still contain these factorizable polynomials
    assert_eq!(gb.len(), 2);
    
    // Check that the original polynomials are in the ideal generated by the basis
    // (This is always true for a Gröbner basis)
}

#[test]
fn test_groebner_basis_ordering_matters() {
    let field = RingValue::from(ArkFieldWrapper::<BnFr>::new());
    let poly_ring = MultivariatePolyRingImpl::new(&field, 2);
    
    let system = poly_ring.with_wrapped_indeterminates(|[x, y]| {
        vec![
            x.clone() * y.clone() - 1,
            x.clone().pow(2) - y.clone(),
        ]
    });
    
    // Compute with Lex ordering
    let gb_lex = buchberger(&poly_ring, system.clone(), Lex, |_| {}).unwrap();
    
    // Compute with DegRevLex ordering
    let gb_degrevlex = buchberger(&poly_ring, system, DegRevLex, |_| {}).unwrap();
    
    // The bases may be different sizes or contain different polynomials
    // Both are correct, just optimized for different purposes
    println!("Lex basis size: {}", gb_lex.len());
    println!("DegRevLex basis size: {}", gb_degrevlex.len());
    
    // Both should be non-empty
    assert!(gb_lex.len() > 0);
    assert!(gb_degrevlex.len() > 0);
}

#[test]
fn test_groebner_basis_three_variables() {
    let field = &*BN254_FR;
    let poly_ring = MultivariatePolyRingImpl::new(field, 3);
    
    // Cyclic system
    let system = poly_ring.with_wrapped_indeterminates(|[x, y, z]| {
        vec![
            x.clone() + y.clone() + z.clone(),          // x + y + z = 0
            x.clone() * y.clone() + y.clone() * z.clone() + z.clone() * x.clone(),  // xy + yz + zx = 0
            x.clone() * y.clone() * z.clone() - 1,     // xyz = 1
        ]
    });
    
    let result = buchberger(&poly_ring, system, DegRevLex, |_| {});
    
    match result {
        Ok(gb) => {
            assert!(gb.len() > 0);
            println!("3-variable Gröbner basis has {} polynomials", gb.len());
        }
        Err(e) => {
            // Some systems might be too complex or hit computational limits
            println!("Gröbner basis computation failed (expected for complex systems): {:?}", e);
        }
    }
}

#[test]
fn test_groebner_basis_elimination() {
    let field = RingValue::from(ArkFieldWrapper::<BlsFr>::new());
    let poly_ring = MultivariatePolyRingImpl::new(&field, 3);
    
    // System for elimination: we want to eliminate z
    // x + y + z - 3 = 0
    // x - z - 1 = 0
    // y + 2z - 2 = 0
    let system = poly_ring.with_wrapped_indeterminates(|[x, y, z]| {
        vec![
            x.clone() + y.clone() + z.clone() - 3,
            x.clone() - z.clone() - 1,
            y.clone() + 2 * z.clone() - 2,
        ]
    });
    
    // With Lex ordering (x > y > z), the basis should contain polynomials
    // that don't involve z (elimination ideal)
    let gb = buchberger(&poly_ring, system, Lex, |_| {}).unwrap();
    
    // Check if we have polynomials in just x and y (no z)
    let mut found_eliminated = false;
    for poly in &gb {
        let involves_z = poly_ring.terms(poly).any(|(_, m)| {
            m.exponents()[2] > 0  // z is the third variable (index 2)
        });
        
        if !involves_z && !poly_ring.is_zero(poly) {
            found_eliminated = true;
            println!("Found polynomial without z (eliminated)");
        }
    }
    
    // Lex ordering should produce elimination
    assert!(found_eliminated || gb.len() == 1);  // Unless system is trivial
}

#[test]
fn test_groebner_basis_empty_system() {
    let field = RingValue::from(ArkFieldWrapper::<BnFr>::new());
    let poly_ring = MultivariatePolyRingImpl::new(&field, 2);
    
    let empty_system: Vec<_> = vec![];
    
    let gb = buchberger(&poly_ring, empty_system, DegRevLex, |_| {}).unwrap();
    
    // Empty system should give empty basis
    assert_eq!(gb.len(), 0);
}

#[test]
fn test_groebner_basis_single_polynomial() {
    let field = &*BLS12_381_FR;
    let poly_ring = MultivariatePolyRingImpl::new(field, 2);
    
    // Single polynomial system
    let system = poly_ring.with_wrapped_indeterminates(|[x, y]| {
        vec![x.clone().pow(3) - y.clone().pow(2)]
    });
    
    let gb = buchberger(&poly_ring, system, DegRevLex, |_| {}).unwrap();
    
    // Should contain at least the original polynomial
    assert_eq!(gb.len(), 1);
}

#[test]
fn test_groebner_basis_inconsistent_system() {
    let field = RingValue::from(ArkFieldWrapper::<BlsFr>::new());
    let poly_ring = MultivariatePolyRingImpl::new(&field, 2);
    
    // Inconsistent system: x = 1, x = 2
    let system = poly_ring.with_wrapped_indeterminates(|[x, _y]| {
        vec![
            x.clone() - 1,
            x.clone() - 2,
        ]
    });
    
    let gb = buchberger(&poly_ring, system, DegRevLex, |_| {}).unwrap();
    
    // Should reduce to {1} (inconsistent)
    assert_eq!(gb.len(), 1);
    assert!(poly_ring.is_one(&gb[0]));
}

#[test]
fn test_groebner_basis_field_properties() {
    use prime_field::FieldProperties;
    
    let field_wrapper = ArkFieldWrapper::<BnFr>::new();
    let field = RingValue::from(field_wrapper);
    let poly_ring = MultivariatePolyRingImpl::new(&field, 2);
    
    // Use field characteristic in the system
    let char = field_wrapper.characteristic();
    println!("Working over field with characteristic: {} bits", char.bits());
    
    // In a field of characteristic p, x^p = x (Fermat's little theorem)
    // This property should be preserved in computations
    assert!(field_wrapper.is_prime_field());
    
    // Simple system to test field properties
    let system = poly_ring.with_wrapped_indeterminates(|[x, y]| {
        vec![
            x.clone() + y.clone() - 1,
            x.clone() * y.clone(),  // xy = 0, so either x=0 or y=0
        ]
    });
    
    let gb = buchberger(&poly_ring, system, Lex, |_| {}).unwrap();
    assert!(gb.len() > 0);
}
